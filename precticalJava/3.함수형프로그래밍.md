#### 3.2 여행상품개발
~~~java
    import java.util.ArrayList;
    import java.util.List;
    
    public class  SearchingTravel {
        public static final String CONTRY_VIETNAM = "vietnam";
        public static final String CONTRY_PHILLIPHINE="philliphine";
        public static final String CONTRY_TAILAND = "tailand";
        
        private List<TravleInfo> travleInfoList = new ArrayList<>();
        
        public SearchingTravel() {
            initializeProduct();
        }
        
        private void initializeProduct() {
            TravleInfo cebu = new TravleInfo();
            cebu.setName("cebu Travel");
            cebu.setCountry(CONTRY_PHILLIPHINE);
            cebu.setCity("cebu");
            cebu.setDays(5);
            cebu.setNights(3);
            travleInfoList.add(cebu);
            
            TravleInfo boracay = new TravleInfo();
            boracay.setName("boracay Travel");
            boracay.setCountry(CONTRY_PHILLIPHINE);
            boracay.setCity("boracay");
            boracay.setDays(5);
            boracay.setNights(3);
            travleInfoList.add(boracay);
            
            ...
            
            TravleInfo hanoi = new TravleInfo();
            boracay.setName("hanoi Travel");
            boracay.setCountry(CONTRY_VIETNAM);
            boracay.setCity("hanoi");
            boracay.setDays(3);
            boracay.setNights(2);
            travleInfoList.add(hanoi);
        }
        //국가명으로 여행상품 조회
        public List<TravelInfo> searchTravelInfo(String country) {
            List<TravelInfo> rtnList = new ArrayList<>();
            for(TravelInfo info : travleInfoList){
                if(country.equals(info.getCountry())) {
                    rtnList.add(info);
                }
            }
            return rtnList;
        }
        
        public static void main(String[] args){
          SearchingTravel travelSearch = new SearchingTravel();
          //베트남 여행상품
          List<TravelInfo> searchList = travelSearch.searchTravelInfo(SearchingTravel.CONTRY_VIETNAM);
          for(TravelInfo info :searchList) {
              System.out.println(info);
          }
        }
        
    }
~~~

```java
public class  TravelInfo {
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public int getDays() {
        return days;
    }

    public void setDays(int days) {
        this.days = days;
    }

    public int getNights() {
        return nights;
    }

    public void setNights(int nights) {
        this.nights = nights;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    private String city;
    private int days;
    private int nights;
    private String name;
    private String country;
    
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append(name).append(" : ")
               .append(country).append(" , ")
               .append(city).append(" , ")
               .append(days).append("박 ")
               .append(nights).append("일");
        return builder.toString();
    }
}
```

#### 3.3 조회조건 추가

* 기능추가 : 도시이름 조회 

~~~java
    import java.util.ArrayList;
    import java.util.List;
    
    public class  NewSearchingTravel {
        public static final String CONTRY_VIETNAM = "vietnam";
        public static final String CONTRY_PHILLIPHINE="philliphine";
        public static final String CONTRY_TAILAND = "tailand";
        
        private List<TravleInfo> travleInfoList = new ArrayList<>();
        
        public NewSearchingTravel() {
            initializeProduct();
        }
        
        private void initializeProduct() {
            TravleInfo cebu = new TravleInfo();
            cebu.setName("cebu Travel");
            cebu.setCountry(CONTRY_PHILLIPHINE);
            cebu.setCity("cebu");
            cebu.setDays(5);
            cebu.setNights(3);
            travleInfoList.add(cebu);
            
            TravleInfo boracay = new TravleInfo();
            boracay.setName("boracay Travel");
            boracay.setCountry(CONTRY_PHILLIPHINE);
            boracay.setCity("boracay");
            boracay.setDays(5);
            boracay.setNights(3);
            travleInfoList.add(boracay);
            
            ...
            
            TravleInfo hanoi = new TravleInfo();
            boracay.setName("hanoi Travel");
            boracay.setCountry(CONTRY_VIETNAM);
            boracay.setCity("hanoi");
            boracay.setDays(3);
            boracay.setNights(2);
            travleInfoList.add(hanoi);
        }
        //국가명으로 여행상품 조회
        public List<TravelInfo> searchTravelInfo(String country) {
            List<TravelInfo> rtnList = new ArrayList<>();
            for(TravelInfo info : travleInfoList){
                if(country.equals(info.getCountry())) {
                    rtnList.add(info);
                }
            }
            return rtnList;
        }
        
         //도시명으로 여행상품 조회
         public List<TravelInfo> searchTravelInfoByCity(String city) {
             List<TravelInfo> rtnList = new ArrayList<>();
             for(TravelInfo info : travleInfoList){
                 if(country.equals(info.getCity())) {
                     rtnList.add(info);
                 }
             }
             return rtnList;
         }
                 
        
        public static void main(String[] args){
            NewSearchingTravel travelSearch = new NewSearchingTravel();
            //베트남 여행상품
            List<TravelInfo> searchList = travelSearch.searchTravelInfo(SearchingTravel.CONTRY_VIETNAM);
            for(TravelInfo info :searchList) {
                System.out.println(info);
            }
          
            //베트남 여행상품
            List<TravelInfo> searchListByCity = travelSearch.searchTravelInfoByCity("cebu");
            for(TravelInfo info :searchListByCity) {
                System.out.println(info);
            }
        }
        
    }
~~~

* 조건이 추가되거나 변경될 때마다 메서드가 계속 추가되는 구조
* 추가된 메서드 내용이 비슷하다. 
* 두조건을 충족하려면 새로운 메서드를 만들어야 한다
* 요건 변경에 따라 클래스가 자주 변경되며 이를 사용하는 클래스에 큰 영향을 미친다.

``` java

        public List<TravelInfo> searchTravelInfo(String gubun, String searchValue) {
             List<TravelInfo> rtnList = new ArrayList<>();
             
             for(TravelInfo info : travleInfoList){
                 if("country".equals(gubun) {
                    if(country.equals(info.getCity())) {
                         rtnList.add(info);
                     }
                 }else if("city".equals(gubun){
                     if(country.equals(info.getCity())) {
                         rtnList.add(info);
                     }
                 }
             }
             return rtnList;
         }
```

메서드를 2 ==> 1개로 줄였지만 중복도가 높다. AND 조건등 다른 조건이 추가되는 요건에 대응할 수 없다.

#### 3.4 인터페이스로 대응

```java
    public interface TravelInfoFilter{
        public boolean isMatched(TravelInfoVO info);
    }
```
자바8에서 하나의 메서드만 정의한 것을 함수형 인터페이스라고 한다.

```java

    import java.util.ArrayList;
    import java.util.List;
    
    public class  NewSearchingTravel {

        private List<TravelInfo> travelInfoList = new ArrayList<>();
        public NewSearchingTravel() {...}
        
        //외부에서 전달된 조건으로 검색
        public List<TravelInfoVO> searchTravelInfo(TravelInfoFilter sCondition) {
             List<TravelInfoVO> rtnList = new ArrayList<>();
             for(TravelInfoVO vo : travelInfoList){
                 //인터페이스 isMatched 메서드를 호출, 실제 구현에 대해서는 캡슐화되어 있다.
                 if(sCondition.isMatched(vo)) {
                     rtnList.add(vo);
                 }
             }
             return rtnList;
        }

        public static void main(String[] args) {
            NewSearchingTravel travelSearch = new NewSearchingTravel();
            
            List<TravelInfoVO> searchTravel = 
                    travelSearch.searchTravelInfo(new TravelInfoFilter(){
                        public boolean isMatched(TravelInfoVO travelInfo){
                            if(travelInfo.getCountry().equals("vietnam")) {
                                return true;
                            }else {
                                return false;
                            }
                        }          
                    });
        }
    }
```
인터페이스를 이옹해 조회 조건을 외부로 분리시키고 여행상품정보를 관리에만 집중하도록 구현했다.
이것이 인터페이스를 이용해서 분리한 대표적인 패턴이다.
#### 3.5 람다표현식으로 코드 함축
~~~java
     List<TravelInfoVO> searchTravel =
        travelSearch.searchTravelInfo(new TravelInfoFilter(){
        public boolean isMatched(TravelInfoVO travelInfo){
            if(travelInfo.getCity().equals("hanoi")) {
                return true;
            }else {
                return false;
            }
        }
     });
~~~

익명클래스 방식은 일부 코드를 위해 반복적인 패턴을 작업해야 하며 익명클래스의 경우 가독성이 떨어진다.
익명클래스는 컴파일시 클래스 파일이 별도로 생성된다.
배포나 업데이트시 불편함이 계속 따라다닌다. 이런 불편함 때문에 람다 표현식을 사용한다.
~~~java
    List<TravelInfoVO> searchTravel = travelSearch.searchInfo(
        (TravelInfoVO travelInfo)->travelInfo.getCountry().equals("vietnam"));
    List<TravelInfoVO> searchTravelByCity = travelSearch.searchInfo(
        (TravelInfoVO travelInfo)->travelInfo.getCity().equals("hanoi"));
~~~
람다표현식은 중복도가 개선되기때문에 가독성이 높아진다.


