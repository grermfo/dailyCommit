#### 4.2 람다 표현식이 필요한 이유
프레임 워크와 라이브러리가 추가 되면서 유연성과 다양성을 확보하기 위해 인터페이스 기반으로 개발을 많이 하는데, 이 때문에
프로그램의 명세(인터페이스)와 구현(클래스)을 분리해 결과적으로 많은 클래스 파일이 생긴다. 경우에 따라 인터페이스만 제공되는
경우도 있어 별도로 구현 클래스를 만들기도 하고 중첩클래스나 익명 클래스로 실제 구현하다 보니 비즈니스 로직의 구현보다 
그것을 담기 위한 코드들이 더 많이 작성되면서 중복되는 코드가 많아지는 문제가 생긴다. 
이런 반복적이고 비효울적인 구조를 개선하고자 (익명클래스의 사용을 줄이기 위한) 람다 표현식이 익명클래스를 대체 하는데
유용한다.

```java
    public class BaseballPlayer implements Comparable<BaseballPlayer> {
        private String teamName;
        private String playerName;
        private String position;
        private String ranking;
        
        ...
        
        @Override
        public int compare(BaseballPlayer player){
            return playerName.compareTo(player.getPlayerName());
        }
    }

```

Comparable 인터페이스를 구현하려면 해당 인터페이스에 유일하게 제공되는 compareTo메서드를 구현해야 한다.
클래스 내부에 직접 Comparable 인터페이스를 구현하는 경우도 있지만 클래스가 해당기능을 정의하지 않았을 경우 외부에서 
비교 기능을 정의해서 주입하는 경우도 있다.

```java
    public class SortCollection{
        List<BaseballPlayer> list = new ArrayList<BaseballPlayer>();
        
        public static void main(String[] args){
            //자바8에서만 컴파일 된다. 정렬에 대한 규칙을 정의한다.
            list.sort(new Comparator<BaseballPlayer>() {
              @Override
              public int compare(BaseballPlayer player1, BaseballPlayer player2) {
                  return player1.getPlayerName().compareTo(player2.getPlayerName());
              }
          });
        }
    }
```

sort메서드는 Comparator 인터페이스를 파라미터로 받도록 정의해 놓았으며 정렬에 대한 상세 기준을 개발자가 
스스로 정의하도록 남겨 놓았다.

sort(Comparator<? super E> c)
객체의 정렬은 기준도 객체마다 다양하기 때문에 자바 컬렉션 프레임워크에서는 비교관련 연산을 직접 구현하지 않고
외부에서 정의해서 전달하도록 인터페이스로 남겨 놓았다. 복잡한 내용이 아니기 때문에 별도의 클래스를 생성하지 않고
compareTo 메서드를 익명클래스로 직접 구현 작성하였다.

스프링 프에임워크는 다른 프레임워크에 비해 인터페이스를 많이 활용하는 편이다.
필요한 모든 것을 인터페이스와 클래스로 분리하도록 권하고 있고 프레임워크 자체에서도 쉽게 활용할 수 있는 많은 템플릿을 
인터페이스로 제공하고 있다.

```java
    public class JdbcTemplateExample {
        SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
        JdbcTemplate jdbcTemplate= new JdbcTemplate();
        jdbcTemplate.setDataSource(dataSource);
        jdbcTemplate.update("Insert into...");
        
        List<BaseballPlayer> results = 
            jdbcTemplate.query("SELECT * FROM BASEBALL_PLAYER_INFO...", 
            new RowMapper<BaseballPlayer>(){
                public Contact mapRow(ResultSet result , int rowNum) throws Exception{
                    BaseballPlayer player = new BaseballPlayer();
                    player.setTeamName(result.getString("TEAM_NAME"));
                    player.setPlayerName(result.getString("PLAYER_NAME"));
                    player.setPosition(result.getString("POSITION"));
                    player.setRanking(result.getString("RANKING"));
                    return player;
                }
            }
        );
    }
```

익명클래스 사용시 문제점은 반복되는 코드를 너무 많이 추가해야 하는 문제점이다.
메서드의 파라미터로 전달할 수 있는 값이 기본형 데이터(int, double, etc)와 객체형만 가능하기 때문이다. 
그래서 기본형과 객체형외에도 행동을 정의하는 코드를 인수로 전달할 수 있도록 람다표현식을 메서드의 
인수로 전달할 수 있도록 바꾸었다.

```java
    //람다 표현식
    List.sort(
        (BaseballPlayer player1, BaseballPlayer player2)
         -> plyer1.getPlayerName().compareTo(plyer2.getPlayerName())
            );

```

```java
    //익명클래스
    list.sort(new Comparator<BaseballPlayer>() {
         @Override
         public int compare(BaseballPlayer player1, BaseballPlayer player2) {
             return player1.getPlayerName().compareTo(player2.getPlayerName());
         }
     });

```
* 이름없는 함수를 선언할 수 있다. 메서드는 반드시 특정 클래스나 인터페이스 안에 포함되어야 하고 
메서드 이름이 있어야 하지만 람다표현식은 이러한 제약에서 벗어날 수 있다.
* 코드를 파라미터로 전달할 수 있다. 외부에서 동작을 정의해서 메서드에 전달할 때 편리하게 사용할 수 있다.

#### 4.3 람다 표현식 이해하기
